---

layout: post
title: agent框架
category: 架构
tags: MachineLearning
keywords: agent

---

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$']], // 支持 $和$$ 作为行内公式分隔符
      displayMath: [['$$', '$$']], // 块级公式分隔符
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script async src="/public/js/mathjax/es5/tex-mml-chtml.js"></script>

* TOC
{:toc}

## 简介（未完成）

## 理念之争：agent vs workflow

[OpenAI“Agent万能论”遭打脸！LangChain创始人：Deep Search恰恰证明Workflows不可取代](https://mp.weixin.qq.com/s/vEaVEIM_hD2IE4ZVdotEgA)
1. LangChain创始人与OpenAI就Agent框架设计理念产生争议，认为不应将Agents和Workflows严格二分，大多数Agentic系统是两者结合；他指出Agent框架核心难点是确保LLM在每步都能获得恰当上下文，而非仅提供封装，框架应支持从结构化工作流到模型驱动的灵活转换；
2. 有些人将 Agent 视为完全自主的系统，能够长时间独立运行，灵活使用各种工具来完成复杂任务。 也有些人认为 Agent 是遵循预设规则、按照固定 Workflows 运作的系统。在 Anthropic，我们把所有这些变体都归类为 Agentic 系统，但在架构上，我们明确区分 Workflows 和 Agents：
    1. Workflows：依靠预先编写好的代码路径，协调 LLM 和工具完成任务；
    2. Agents：由 LLM 动态推理，自主决定任务流程与工具使用，拥有更大的决策自由度。
3. 让 Agents 稳定可靠地工作，依然是个巨大的挑战。LLM 本身能力存在局限性，且在上下文信息传递方面常出现错误或不完整的情况，后者在实践中更为普遍。导致 Agent 效果不佳的常见原因包括：System Message 不完整或过于简短、用户输入模糊不清、未向 LLM 提供正确的工具、工具描述不清晰、缺乏恰当的上下文信息以及工具返回的响应格式不正确。**构建可靠 Agents 的关键挑战在于确保大模型接收到正确的上下文信息**，而 Workflows 的优势在于它们能够将正确的上下文传递给给 LLMs ，可以精确地决定数据如何流动。
4. 许多 Agent 框架提供的 Agent 封装（如包含 prompt、model 和 tools 的类）虽然易于上手，但可能限制对 LLM 输入输出的控制，从而影响可靠性，像 Agents SDK（以及早期的 LangChain， CrewAI 等）这样的框架，既不是声明式的也不是命令式的，它们只是封装。它们提供一个 Agent 封装（一个 Python 类），这个类里面封装了很多用于运行 Agent 的内部逻辑。**它们算不上真正的编排框架，仅仅是一种封装**。 这些封装最终会让你非常非常难以理解或控制到底在每一步传递给 LLM 的具体内容是什么。这一点非常重要，拥有这种控制能力对于构建可靠的 Agents 至关重要。这就是 Agent 封装的危险之处。
5. 在实际应用中，Agentic 系统往往并非由单一 Agent 组成，而是由多个 Agent 协作完成。在多 Agent 系统中，通信机制至关重要。因为构建可靠 Agent 的核心，依然是确保 LLM 能接收到正确、充分的上下文信息。为了实现高效通信，常见的方法包括「Handoffs」（交接）等模式，像 Agents SDK 就提供了这种风格的封装。但有时候，这些 Agents 之间最好的通讯方式是 Workflows。而 Agent 框架则通过提供统一封装、记忆管理、人机协作、流式处理、可观测性和容错机制，大幅降低构建可靠 Agentic 系统的复杂度，但前提是开发者需理解其底层机制。
6. 大模型越来越厉害，那么是不是都会变成 Agents？虽然工具调用 Agents 的性能在提升，但“能够控制输入给 LLM 的内容依然会非常重要（垃圾进，垃圾出）”，**简单的 Agent 循环并不能覆盖所有应用需求**。
    1. OpenAI 的 Deep Research 项目是 Agent 的一个好例子，这同时也证明了针对特定任务训练的模型可以只用简单 Agent 循环。它的成功前提是：“你能针对你的特定任务训练一个 SOTA 模型”，而当前只有大型模型实验室能够做到这一点。对于大多数初创公司或企业用户来说，这并不现实。

总结来看，简单 Agents 在特定条件下有效，但仅限于数据和任务极为匹配的场景。对绝大多数应用而言，Workflows 仍然不可或缺，且生产环境中的 Agentic 系统将是 Workflows 和 Agents 的结合。

## 框架

[Agentic AI：8个开源框架对比-2025更新](https://mp.weixin.qq.com/s/waol_6y7VH_SQZwNBJ9qQw) PS：有细节控制需求用langgraph，稍微抽象好一点可以尝试 Agno
Agentic AI 主要是围绕着大型语言模型（LLMs）构建系统，让它们能够拥有准确的知识、数据访问能力和行动能力。你可以把它看作是使用自然语言来自动化流程和任务。在自动化中使用自然语言处理并不是什么新鲜事 - 我们已经用 NLP 多年来提取和处理数据了。新的是我们现在能给语言模型的自由度，允许它们处理模糊性并动态做出决策。没错，大模型的优势就是处理模糊性和有一定的规划能力。但仅仅因为 LLMs 能理解语言，并不意味着它们就有代理性 - 甚至理解你想要自动化的任务。这就是为什么构建可靠系统需要大量的工程技术。**框架的核心，是帮你进行提示工程化和管理数据在大型语言模型（LLMs）之间的传输——但它们也提供了额外的抽象层，让你更容易上手**。

大多数框架都带有相同的核心构建模块：支持不同的模型、工具、内存和RAG。
1. 大多数开源框架或多或少都是模型不可知的。这意味着它们被构建为支持各种提供商。
2. 所有具有代理性的框架都支持工具化，因为工具对于构建能够采取行动的系统至关重要。它们还使得通过简单的抽象定义自己的自定义工具变得容易。如今，大多数框架都支持MCP，无论是官方的还是通过社区解决方案的。
3. 为了使代理能够在LLM调用之间保留短期记忆，所有框架都使用状态。状态帮助LLM记住在早期步骤或对话的部分中说过的内容。
4. 大多数框架还提供简单的选项来设置RAG，与不同的数据库结合，为代理提供知识。
5. 最后，几乎所有框架都支持异步调用、结构化输出、流式传输以及添加可观察性的能力。

有些框架缺少的东西
1. 有些框架有内置的多模态处理解决方案- 也就是文本、图像和声音。只要模型支持，你完全可以自己实现这一点。
3. 短期记忆（状态）总是包括在内的 - 没有它，你就无法构建一个使用工具的系统。然而，**长期记忆更难实现**，这也是框架之间的差异所在。有些提供内置解决方案，而其他的则需要你自己去连接其他解决方案。
3. 框架在处理多智能体能力方面也各不相同。多智能体系统允许你构建协作或分层的设置，通过监督者连接智能体团队。

框架在抽象程度、给予Agent的控制权以及你需要编写多少代码才能让事情运行起来方面各不相同。
1. 抽象程度。CrewAI 和在某种程度上的 Agno 都是为即插即用而设计的。 LangGraph也有相当的抽象程度，但它使用基于图的系统，你需要手动连接节点。这给了你更多的控制权，但也意味着你必须自己设置和管理每个连接，这带来了更陡峭的学习曲线。
2. 另一个区别点是框架假设Agent应该有多少自主权。有些是建立在这样的想法上：LLMs 应该足够聪明，能够自己弄清楚如何完成任务。其他的则倾向于严格控制 - 给代理一个任务，并一步一步指导它们。AutoGen 和 SmolAgents 属于第一种类型。其余的更倾向于控制。

