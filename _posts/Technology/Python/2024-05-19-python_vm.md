---

layout: post
title: Python虚拟机
category: 技术
tags: Python
keywords: Python

---

* TOC
{:toc}


## 简介

## 虚拟机

Python 虚拟机设计了一种基于栈的字节码，执行过程简洁高效。Python 语言既支持面向对象编程，也支持将函数做为语言的第一类公民，支持自动内存管理。支持语言的动态特性，例如运行时修改类定义、反射等。

编程语言虚拟机的一个重要能力就是屏蔽硬件差异。
1. 以 Java 为例，Java 源代码文件会被 javac 先编译生成 class 文件，多个 class 文件可以集中在一起，生成一个 jar 文件。字节码的设计非常类似于 CPU 指令，它有自己定义的数值计算、位操作、比较操作、跳转操作等。所以人们把这种专门为某一类编程语言所开发的字节码以及其解释器合并称为编程语言虚拟机。
2. 以 V8 为代表的 JavaScript 虚拟机。网页上的 JS 代码都是以源代码的形式由服务端发送到客户端，然后客户端来执行的。相比 Java 的执行过程，这一过程中缺少了编译生成字节码的步骤。它根本不需要生成字节码，而是直接将源代码翻译成树形结构，我们称之为抽象语法树。然后，V8 的执行器就通过后序遍历这棵树，在访问语法树上的不同结点时，执行与这个结点相对应的动作，最终完成代码的解释执行。这种做法是把源代码的编译和程序的执行直接绑定在一起。
3. 以 Go 为代表的静态编译的类型。如果对 Go 语言的源代码进行编译的话，你会发现，即使是很小的一段代码，编译的可执行程序的体积也会很大，这是因为 Go 在编译的时候直接将虚拟机与用户代码链接在了一起。好处是，既能通过虚拟机实现对硬件平台和操作系统的屏蔽，又能提供很好的执行效率。
4. Python 比较灵活，一方面它规定了自己的字节码，但它又不要求程序必须以字节码文件（.pyc）来发布。它完全支持甚至鼓励应用程序以源代码的方式发行。本质上，在 Python 虚拟机内部，源代码也是先编译成字节码然后再执行的，也就是说 Python 的编译器 Python 虚拟机的一部分，它不像 Java 虚拟机，javac 用于编译，和执行是分离的。你可以回忆一下 Python 中的 eval 功能，其实 eval 就是调用了 Python 内置的编译器，来编译字符串。CPython 虚拟机既可以执行 py 文件，也可以执行编译过的 pyc 文件，这是因为**CPython 里包含了一个可以编译 py 文件的编译器**，在执行 py 文件时，第一步就是要把 py 文件先翻译成字节码文件。当然 Python 虚拟机也有其他的开源实现，例如，Jython 是一种用 Java 实现的 Python 语言，它的原理与 CPython 大有不同，它放弃了 Python 的原生字节码，直接将 py 源代码文件翻译成了由 Java 字节码组成的 class 文件。而我们知道，class 文件是可以直接在 Java 虚拟机上执行的，这样一来，Python 代码就可以自由地使用各种强大的 Java 类库。通过编译，Jython 实现了 Python 与 Java 的无缝衔接。

编程语言的发展为虚拟机技术提供了源动力，而虚拟机技术的发展则为编程语言的发展提供了根本保障。虚拟机中的很多技术是为了支持对应的语言特性才被发明出来的，同样有很多好用的语言特性也是因为虚拟机技术的长足发展才得以实现。所以说，编程语言和虚拟机技术是相互依赖和对立统一的。

1. 编译器是如何把源代码翻译成字节码的？词法分析 ==> 语法分析 ==> 生成抽象语法树 ==> 生成字节码。 
2. 虚拟机是如何执行字节码的？
    1. 虚拟机的代码里不使用任何的 STL 内建库，这是因为虚拟机中的字符串、整数、列表、字典等结构未来都应该由垃圾回收器自动管理。所以虚拟机必须对数据结构中的每一个字节的分配位置和生命周期有完全的掌控权，这就必然要求所有的数据结构都自主实现，而不能使用第三方类库。
    2. 对于一个简单的运算，如果使用 C 语言，经过 GCC 等编译器的优化，只需要三四条机器指令就可以完成了。而使用解释执行，最少也要几百条指令才能完成。所以采用解释执行的 Python、Lua 等脚本语言相比 C 语言等静态编译语言，性能表现上往往有数量级的差距。
    3. 不过可以用即时编译（Just In Time，JIT）来弥补，JIT两大核心机制：可写可执行的内存区域，确保在运行期可以生成可执行的机器码（把我们手写的机器码复制进去，然后使用一个函数指针指向这块内存，并且调用它，就可以执行这一段手写的机器码了）；基于性能采样的编译优化（Profiling Guided Optimization, PGO），可以使 JIT 编译器获得超过静态编译器的运行性能。

Interpreter核心逻辑：逐条取出字节码，然后依次执行。PS： 复杂东西的源头都很简单，比如k8s controller 的reconcile
```c++
void Interpreter::run(HiString* codes) {
    int pc = 0;
    int code_length = codes->length();  

    _stack  = new int[16];  // 创建一个运行时栈
    int top = 0;
    // 使用一个大的循环不断地从字节码数组中取出指令
    while (pc < code_length) {
        unsigned char op_code = codes->value()[pc++];
        bool has_argument = (op_code & 0xFF) >= ByteCode::HAVE_ARGUMENT;

        int op_arg = -1;
        if (has_argument) {
            op_arg = (codes->value()[pc++] & 0xFF);
        }
        int v, w;
        // 分别对不同的指令进行处理
        switch (op_code) {
            case ByteCode::LOAD_CONST:
                _stack[top++] = op_arg;
                break;

            case ByteCode::BINARY_ADD:
                v = _stack[--top];
                w = _stack[--top];
                _stack[top++] = v + w;
                break;

            case ByteCode::BINARY_MULTIPLY:
                v = _stack[--top];
                w = _stack[--top];
                _stack[top++] = v * w;
                break;

            default:
                printf("Error: Unrecognized byte code %d\n", op_code);
        }
    }
    printf("%d\n", _stack[0]);

    delete[] _stack;
}
```


## 内存管理

垃圾回收可以分为引用计数和 Tracing GC 两大类，其中引用计数的代表就是 CPython，也就是我们平常最常使用的社区版 Python。而大多数编程语言虚拟机基本上都使用 Tracing GC。

Python 中一切皆对象。因此，你所看到的一切变量，本质上都是对象的一个指针。那么，怎么知道一个对象，是否永远都不能被调用了呢？引用计数（`sys.getrefcount(a)`，getrefcount 本身也会引入一次计数；在函数调用发生的时候，会产生额外的两次引用，一次来自函数栈，另一个是函数参数。）。

相比 C 语言里，你需要使用 free 去手动释放内存，Python 的垃圾回收在这里可以说是省心省力了。不过，如果我偏偏想手动释放内存，应该怎么做呢？方法同样很简单。你只需要先调用 del a 来删除对象的引用；然后强制调用 gc.collect()，清除没有引用的对象，即可手动启动垃圾回收。

Python 使用标记清除（mark-sweep）算法和分代收集（generational），来启用针对循环引用的自动垃圾回收。先来看标记清除算法。我们先用图论来理解不可达的概念。对于一个有向图，如果从一个节点出发进行遍历，并标记其经过的所有节点；那么，在遍历结束后，所有没有被标记的节点，我们就称之为不可达节点。显而易见，这些节点的存在是没有任何意义的，自然的，我们就需要对它们进行垃圾回收。当然，每次都遍历全图，对于 Python 而言是一种巨大的性能浪费。所以，在 Python 的垃圾回收实现中，mark-sweep 使用双向链表维护了一个数据结构，并且只考虑容器类的对象（只有容器类对象才有可能产生循环引用）。而分代收集算法，则是另一个优化手段。Python 将所有对象分为三代。刚刚创立的对象是第 0 代；经过一次垃圾回收后，依然存在的对象，便会依次从上一代挪到下一代。而每一代启动自动垃圾回收的阈值，则是可以单独指定的。当垃圾回收器中新增对象减去删除对象达到相应的阈值时，就会对这一代对象启动垃圾回收。