---

layout: post
title: 架构大杂烩
category: 架构
tags: Architecture
keywords: 聊聊架构

---

## 简介

* TOC
{:toc}

Martin Fowler 认为软件架构是：重要并且难以改变的决策。

软件架构的设计无非就是前后端的双向打通，前端是面向用户的 user friendly 接口，考验的是程序员对业务的理解与设计；后端是实现功能所依赖的基础能力，考验的是程序员对底层技术的掌握与应用；而前后端的打通，考验的是程序员的能力、经验与审美。

[聊聊架构](http://www.infoq.com/cn/articles/talk-arch?utm_source=articles_about_talk-arch&utm_medium=link&utm_campaign=talk-arch)

[为什么需要关注软件架构](https://mp.weixin.qq.com/s/WFprpXM9URZkpnn4E2v6Uw)许多软件开发人员不信任架构实践，他们相信，如果他们遵循这些实践，可能需要很长时间才能交付一些甚至可能不是客户想要的东西。他们更愿意专注于理解客户的需求，并通过小而快速的敏捷迭代过程来交付产品。他们当中有一些人相信，只要遵循了这些过程，架构自然会“出现”，而不需要有意识地进行计划或架构设计。这种架构方法通常可以交付满足客户所需的产品，这是一个好的开始。但是，如果不**显式考虑产品的可持续性**，它就有可能衰退，导致产品在自然退役前无法维护。
1. 如果我们正在做的事情是我们非常了解的，并且已经做过很多次了，那么预先设计方法就很有效。例如，建造摩天大楼、挖运河、生产产品或建造桥梁。我们可以应用“最佳实践”，并依赖过去已经在这些事情上验证过的有效方法。
2. 如果我们正在处理一些东西是全新的，并且我们不太了解，或者变化太快以至于还没有“最佳实践”，那么预先设计就不起作用了。在这种情况下，作为科学革命基础的可控性实验可以帮助我们更深入地理解问题和可能的解决方案。最终的解决方案“出现”了，只是它沿着有意识的实验的路径向我们招手。问题在于，可控性实验可能无法在合理的时间内产生可持续的解决方案，并且可能需要进行可接受的返工。
软件架构实践可以**通过更早地提出更好的问题来指导实验**，以减少交付可持续产品的时间和成本，并仍然可以保留敏捷方法的优势。**架构的本质由一组定义和约束产品技术面的决策组成**。这些决策专注于产品如何处理质量属性需求（QAR）， 如性能、安全性或可伸缩性。此外，如果架构设计没有强有力地实现组件的抽象和隔离，重构的成本可能会飙升。

广义地说，实现“可持续性”是软件产品架构工作的重点。如果软件产品能够满足当前需求 (包括 QAR)，而不损害满足未来需求的能力，则可以认为该软件产品是可持续的。不幸的是，随着功能增强的实现和新设计决策的制定，软件系统会随着时间的推移而“磨损”，这可能会延展甚至破坏最初的架构设计。常见的“磨损”原因包括：
1. 由于维护系统的开发人员对系统缺乏理解，最初的设计决策也就过时了。与系统设计相关的决策和假设很少会被准确地记录下来。当人们不再针对系统提出问题或回答问题时，软件系统就开始衰退了。提出问题是评估软件系统健康状况的一种重要技术，如果有知识资源可以回答这些问题的话。
2. 技术债务的累积会导致系统维护不再可行或不再具有成本效益，并且无法实现新的功能。
3. 开发人员试图重用不同组件的代码块，他们认为可以通过对复用代码进行微小的改动来实现新功能。遗憾的是，他们可能无法完全理解原始代码所依赖的架构上下文，也意识不到在不同的组件中重用代码可能会在以后产生不必要的副作用，例如性能、可伸缩性或可用性问题。这些软件变更增加了技术债务，并降低了系统的整体质量，除非技术债务能够迅速得到解决。
4. 技术的发展导致一些软件系统运行在不是为它们设计的技术平台上。一些较老的软件系统经历了“灾难性的成功”，因为它们持续存在的时间比最初计划的要长得多，而且它们的技术债务已经变得非常沉重、难以解决且代价巨大，“偿还”起来非常困难。偿还技术债务的成本可能与完全替换该软件系统的成本类似，甚至有过之而无不及。
5. 失败的假设。逻辑的主体，包括软件系统，最终会因为假设的失败而崩溃，软件开发人员可能没有意识到他们所做的假设。隐藏的假设可以被认为是对系统的约束。关键在于要清楚地阐明所有的假设，并保持信息的更新。质量属性需求本身也是一种需要进行验证的假设，它们的实现需要经过经验的测试和确认，如果可能的话，可以使用自动化。性能、可伸缩性、弹性 (例如，使用类似于 Netflix 猴子军团的框架) 和安全性都是很好的例子。质量属性自动化测试的目标是持续对假设 (例如，实现 QAR 仍然是现实的吗？) 进行测试，并用以指导软件系统的演化。

## 多个范畴的生命周期

人一生的生命周期被各种不同的场景、任务、角色、身份切分成了各不相同的生命周期，其中有核心生命周期，有非核心生命周期，有些必须自己做(读书、生活、谈恋爱)，有些可以交给别人做。

在人类历史中，随着工作越来越复杂、工作任务越来越多，人类协作越来越精细，然后就产生了分工，**分工就是人类因为协作产生的生命周期的切分。**

明确了生命周期这个概念就会意识到，随着事物的发展，把它的一部分职能从其核心生命周期切分出去，构造出新的生命周期，能够帮助这一事物明确自身的核心生命周期、明确自己的职责和权力，**有更多时间用在自己擅长的事情上。**

## 代码、技术、业务和管理

**要分得清楚访问代码、业务代码、存储代码、胶水代码各自应在哪些层级**，它们应该是什么角色，而不是所有代码散乱的混在一起，看起来似乎按照经典的MVC分层，实际上业务代码却同时出现在controller/service/dao，这样其实并没有明确的划分。正确的做法应该是controller完成访问逻辑；DAO完成存储逻辑；service完成胶水逻辑，承上启下，利用DTO转换访问参数、执行业务逻辑、调用DAO映射存储模型、再利用DTO把业务处理结果转换为响应结果，业务逻辑在业务模型中实现。如果把业务逻辑跟业务数据在一起实现就是充血模型，进一步深化就是DDD模式。

如果把业务逻辑跟业务数据在一起实现就是充血模型，进一步深化就是DDD模式。只有这样才完成了明确的软件层次划分，每层各司其职、权责对等，否则就是大泥球。明白了这一点，自然就能分得清楚业务的事务跟关系数据库的事务不是一回事，也就不会考虑完成业务上的事务要依赖关系数据库事务确保数据完整性。完全可以把二者分开，利用更符合业务规律的做法去实现，甚至业务本身已经有成熟的方案确保数据完整性，而不再需要依赖关系数据库事务。在业务上对关系数据库事务ACID特性的依赖既然不再是必须，对拥有ACID特性的数据库依赖自然也就不再是必须，完全可以根据业务需要选择合适的存储方案。

业务模型和具体实现不再依赖于某些具体方案的技术特性，**实现了业务与技术的解耦**，也就更容易实现横向扩展。现在又发现横向扩展也是自然界的一个基本特性。无数基本粒子构成原子、无数原子构成一个具体的宏观物体，一个人不够用就增加更多人。**如果一个系统的规模在横向扩展上达到了瓶颈，不能再靠简单的增加数量获得提升的时候，一定是这个系统的组织架构存在某些不合理因素。**

说到这里自然就要说到业务和技术的关系。前面说到软件是现实世界的映射抽象，由虚拟人代替自然人去完成一些工作。要做好软件自然就要理解业务，对业务的理解越深刻就越有可能做出优秀的软件。但是现实世界太复杂了，随着业务发展，软件规模会越来越大，复杂性越来越高，一个人难以胜任全部架构工作，于是就产生了架构师团队，架构师也有了更细致的分工。架构师的生命周期也相应发生了拆分，也就产生了**业务架构、应用架构、系统架构。**

架构师为了能够实现自己的架构思想，自然需要与职能对等的权力。所以架构师其实不是一个纯粹的技术职位，而是拥有管理职能的职位，而不同角色的架构师对技术的要求也不尽相同。《架构整洁之道》的作者Uncle Bob说的那样：“架构师的工作不是作出决策，而是尽可能久地推迟决策，在现在不作出重大决策的情况下构建程序，以便以后有足够信息时再作出决策。

## 《郭东白的架构课》

![](/public/upload/architecture/architecture_action.png)

一名软件架构师要为相对复杂的业务制定，并且引导实施一个结构化的软件方案。这个**发现最终方案和推动实施的过程**，就是架构活动。这个方案需要和企业目标一致，与商业、软件环境相匹配，并且还需要满足各种资源的约束条件。而你作为一个架构师，要在这些方案中找到那个能够最小化资源和成本，最大化商业价值，以及最大化目标用户满意度的方案。最终，你还要组织技术团队交付这个架构设计方案。
1. 在一个企业内，大多数研发任务的交付都与架构师无关。多数时间，研发团队开发的软件解决方案和软件产品是用来服务用户的，不需要架构师的参与。但当**面对跨多个团队，或者是大面积的技术改造时，就需要架构师参与到其中**，来完成软件研发任务的交付。
2. 架构师对研发活动没有完全的决策权。也就是说，架构师无法决定研发项目的选择、优先级、排期、代码实现方式等等。架构师仅仅可以关注、影响和干预这些因素。
3. 做成一件事情，如果周边条件成熟，环境好，那么事情就会进行得很顺利。反过来，如果条件不成熟，或者你逆势而为，那就会很艰难。
    1. 天时，这里指的是商业环境和技术环境的变化趋势。环境复杂多变，那么看清楚变化趋势的本质，就可以让我们的架构决策顺势而为，借助于环境的变化来成就我们的团队、企业。
    2. 地利，就是你作为一个架构师待的地方，你所在企业的文化环境，这是我们作为架构师无法改变的部分。虽然没法改变，但“良禽择木而栖”。
    3. 人和，架构活动中涉及的人主要是研发人员和目标用户。在输入端，架构师需要与多个研发团队协作，因而理解研发方的核心诉求就尤为关键。在输出端，架构师产出方案的最终评判即目标用户的长期满意度。因此深度洞察用户的人性就是保证架构活动成功的关键所在。
4. 生存法则指的是我们作为架构师在设计架构方案和组织架构活动时必须要尊重的一些原则。如果违背这些原则，那么作为一个架构师的生存就会受到威胁。
    1. 有且仅有一个正确的目标。这是架构活动的起点，也是**甄别架构方案的主要输入**
    2. 尊重和顺应人性。从人性角度出发来做决策，才能保障最终**面向用户的方案**具有长期正确性，以及面向研发同学的实施过程具有可行性。
    3. 在有限资源下最大化商业价值。
    4. 必须要考虑到所依赖的商业和技术模块的生命周期。在架构设计的过程中，架构师会有一个相对确定的商业和技术选择空间。一般情况下，要选择已经有规模优势或者是即将有规模优势的技术，而不是选择那些接近衰老期的技术。
    5. 不断干预活动的目标和内容，同时为企业注入外部适应性，最终正确的架构选型会因为有很强的外部适应性而长期存在。
    6. 在一个相对安全的文化环境中探索未知，文化环境是架构师最难影响的，因而架构师要有足够的判断力，认清自己所在的文化环境是否有利于探索正确的架构方案，不要在一个错误的环境中浪费自己的宝贵生命。

其它
1. 当我们去研究各个大战的最后胜出者时会发现，他们都**不是靠全程饱和攻击取胜的**，而是靠对阶段性精确目标的最大化投入从而在惨烈竞争中胜出的。在充分竞争环境下胜出的公司，几乎没有任何一个是通过大范围的搜索商业模式去寻找增长的。在你的决策范围内，如果你不做取舍，那么就只能让别人来替你做取舍。
2. 架构其实也一模一样。架构师必须尽量保障整个架构活动有且仅有一个正确的目标，且这个目标必须和公司的战略意图相匹配。显然，未来充满不确定性，终极目标很难验证，但通过反复问自己这个问题，我们就可以不断逼近这个唯一且正确的架构目标。
3. 讲真话的时候，不是你在反对你的上级，而是你在用一个架构原则来判断另外一个人的决策质量。
4. 架构目标的决策，对于一个人或一个团队的影响是巨大的。所以当你有了一个正确的关于架构目标的决策，要知道这只是一个起点。你还要认真思考这个决策的实施路径，让大家团结在正确的架构目标上，而不是你自己一个人举着架构目标，变成孤家寡人。不要全盘否定别人的观点，而是站在他的视角，看到、并理解他的出发点的正确部分是什么。

架构师需要做的是，在一个相对复杂的问题上引导实施一个结构化的解决方案。这个方案的参与者是一群人，所以架构师的产出不完全靠自己，而是靠撬动一群人来完成架构目标。
1. 确保最终架构方案的可行性。
2. 确保参与方达成一个合理的实施路径，最终能够完成实施。
3. 确保设计方案可以最大化解决方案的结构性。
事实上，这三个条件很难被同时满足。架构师之所以参与一个方案，往往有这么几个原因：已经有现成的方案，但比较复杂；参与团队众多，但各个团队的优先级不一样；公司压力大，能够投入到现存方案的人力资源有限。


[万字长文！Go 后台项目架构思考与重构](https://www.aminer.cn/research_report/5ea534c2ab6e30e67b2c8f6d)
1. 一个好的架构，其终极目标应当是，用最小的人力成本满足构建和维护该系统的需求，而**增加软件可变性就是架构达到最终目标的核心途径**。
2. 架构设计是为了让未来的修改更加容易，但是未来谁又能完全预测准确呢，架构设计或多或少有一定猜测成分在里面，那什么算过度设计呢？从架构的目的是降低人力来看，就是该设计目前没有任何强有力的逻辑能推出能在未来降低修改某种行为的人力成本，或者降低某种行为修改成本的同时，大大增加了另外一种行为的修改成本。

## 其它

李云：我们在编程时，其实包含无意识的两大步骤：第一步完成的是根本任务，即构思好概念和概念之间的关系，这一步我称之为“软件设计”；第二步完成的是次要任务，即在满足时间冗余度和空间冗余度的情形下，将概念用编程语言表达出来，这一步就是编码工作。布鲁克斯指出，过去软件生产效率的巨大进步得益于在次要任务上投入了巨大的努力。比如，新的编程语言、更快的处理器等。然而，除非次要任务占整个软件开发活动的 90%，否则即便将次要任务所花费的时间缩减到零，也不能带来软件生产效率数量级的提高。这就是“没有银弹”四个字的核心所指。即便进入 21 世纪的今天，这一论断依然成立。软件行业在根本任务的生产效率上，并没有取得次要任务那样质的进步。回到“程序易于理解的核心是什么”这个问题上，我对好程序的第二层理解是：**好程序有着清晰、颗粒度合适、连贯且一致的概念**。强调概念质量的背后，表达的是对程序的软件设计质量的高要求，这样的程序才易于理解。概念能力是指个体理解、分析和处理复杂概念和问题的能力。这种能力通常涉及从现象中抽象出关键信息，形成整合的观念和理论，进而能够对复杂的情境进行有效的理解和处理。你知道吗？概念能力是人类应对复杂度的一种独特能力，帮助我们理解并解决大量个例问题。新概念的提出一开始会带来更高的概念成本，需要我们花一定的时间去学习和掌握。可一旦概念被普及，就能提升沟通的效率。那我们为什么最终会喜欢新的概念呢？因为概念将大大降低大脑需要处理的信息量，降低生物能耗，是进化带给我们的一种生存能力使然。在工作中，你可能听到过“分而治之”这个词，讲的是对一个复杂的软件系统，用以大化小、拼积木的方法来实现。当你知道了程序中概念的核心作用后，就可以理解为，复杂的软件系统是通过概念的切分与塑造来实现的。
1. 第一层理解是：让人易于理解的程序才是好程序。
2. 第二层理解是：好程序有着清晰、颗粒度合适、连贯且一致的概念。
3. 好程序的第三层理解：好程序是让人容易修改的。对于代码来说，我们怕的不是它不完善，而是改不动。
“程序的性能、算法、内存开销等要素，为何没有作为好程序的评价指标？”好程序是通过优化而演进出来的。因此，只要程序易懂又好改，其他的问题都不是问题。

布鲁克斯指出软件开发活动由根本任务和次要任务组成。进一步我总结为，根本任务是“软件设计”，次要任务是“编码”，所以我们会有“软件开发 =k × 软件设计 + 编码”这个公式，其中 k 是远大于 1 的系数，软件设计能力才是行业最稀缺的能力。换句话说，软件设计能力是工程师的核心竞争壁垒。软件开发活动的关键是要解决现实问题，这就需要我们根据纷繁复杂的现象和需求，通过抽象和洞察化繁为简。先来说说抽象能力。抽象动作的背后，需要咱有良好的概念能力才行。软件设计能力之所以能成为工程师的竞争壁垒，是因为背后所需的概念能力需要花很多时间来培养，无法速成。
1. 对复杂概念和系统的深刻理解需要时间。我们需要在实践中反复应用这些概念，从而深化理解。
2. 经验积累需要时间。概念能力往往与个人的经验紧密相关，通过经历不同的项目、挑战和失败，我们才能更好地理解和应用抽象概念。
3. 思维模式的转变需要时间。发展概念能力，通常需要我们改变和扩展现有的思维模式，这种转变并非一蹴而就，而是随着时间和经验的积累逐渐完成的。
说完抽象能力，接下来咱来说一说洞察能力，或简称为洞察力。洞察力通常指对现象或问题深刻而敏锐的理解，它涉及快速准确地捕捉到核心问题或隐藏的模式，并能理解背后的深层含义。洞察力是概念能力的一部分，但更侧重于直觉。就概念能力和洞察力，我简单总结一下。概念能力是一种更广泛的认知能力，涵盖了从现象抽象和形成概念的能力；而洞察力则是在此基础上，对特定情境的深入理解和感知。两者共同作用，使个体能够有效地理解和处理复杂的问题，最后做出有洞察力的行为，比如决策、表达观点等。为了让你对洞察力有更具体的认识，就软件设计我想和你分享我的两个洞察。
1. 第一个洞察是，越复杂的软件，对工程师软件设计能力的要求就越高。因此，我鼓励你抓住机会，参与更大规模软件项目的开发工作。或者，在已参与的软件项目中，承担更大范围的软件维护和迭代演进责任。这些机会都能很好地锻炼咱驾驭复杂软件的能力，锻炼个体的软件设计能力。
2. 第二个洞察是，规模越大的软件，软件设计质量对整个软件产品质量的贡献也越大。

[如何画好一张架构图？](https://mp.weixin.qq.com/s/2HjvNnfP7bLNQF5xh8PxIQ)
1. I claim that you want to start communicating between independent modules no sooner than you absolutely HAVE to, and that you should avoid splitting things up until you really need to, because that communication complexity often swamps the complexity of the actual pieces involved in it.（让我们认识到一种现象，把复杂系统拆分成模块，似乎并没有降低整个系统的复杂度。它降低的只是子系统的复杂度。而整个系统的复杂度，反而会由于拆分后的模块之间，不得不进行交互，变得更加复杂。）
2. The fundamental organization of a system, embodied in its components, their relationships to each other and the environment, and the principles governing its design and evolution.　Architecture = Structure of Component + Relationships + Principles & Guidelines。
3. 架构的本质是为了管理复杂性；架构的本质就是对系统进行有序化重构，不断减少系统的“熵”，使系统不断进化；架构的本质就是对系统进行有序化重构，以符合当前业务的发展，并可以快速扩展。架构的过程其实就是建模的过程。
4. 架构的核心目的：管理复杂性，效率最大化。架构的两个主要变化来源：一个是以改善软件质量为目的的内在结构性变化；另外一个是以满足客户需求为目的的外在功能性变化。

[我对技术架构的理解与架构师角色的思考](https://mp.weixin.qq.com/s/GQZuxBw8mdWv67naal3PCg)每时每刻都在发生技术的升级和变革，需要持续不断地学习，才能对老的架构有新的认识，对于老问题产生新的解法。为什么你能解决这个问题，并且能解决这一类问题？一定是需要你看的多，想的多，这背后是大量的实践和知识的积累，并且是站在过去的肩膀上。
架构师需要什么样的能力？
1. 发现问题，
    1. 对于一个局部/全局的问题，需要有发现的眼光，更应该有发现未发生问题的能力
    2. 每天都会面对很多问题，**哪些需要治标，哪些需要治本**，这个是发现问题的基本判断力。 
2. 定义/分析问题。将发现的问题，进行抽象和归纳，定义出问题的基本要素，同时定义问题的短期和长期方案，推进技术的进步。
3. 解决问题
    1. 制定问题的实施路径和解决方案，怎么把这个问题说清楚，切中问题的点，协同团队和上下游推进问题的解决
    2. 架构师需要能救火，但不仅仅是救眼前的火，更应该救未来的火。

徐文浩：在公司里，我每天在做的，其实主要就是两件事情。
1. 一件事情，我称之为“让事情按次发生”，主要是规划和推动公司里想要做的事情，推动产品结合业务往前走。
2. 另一件事情，我称之为“面对问题，解决问题”，主要是给各种突发的、意料之外的问题找解决办法。


[如何设计一个复杂的业务系统?](https://mp.weixin.qq.com/s/IWgywVo64vcjCmYcmEM4-g)软件架构设计本身就是一个复杂的事情，但其实业界已有一个共识，那就是“通过组件化完成关注点的分离从而降低局部复杂度”。

[一次关于架构的“嘴炮”](https://mp.weixin.qq.com/s/SJ6CNHo0CgiprbC1zQc9lg)

[得先理解什么是架构](https://mp.weixin.qq.com/s/HCXYyjf6IhqDBw9HMJjUzw) 毕加索的牛
1. 如同素描，可能架构师和实现工程师都会画“眼睛”，但架构师关心的是“整个人是什么样的，眼睛的位置和角度是在这个地方”，实现工程师关心的是“知道眼睛在这个地方和这个人的年龄和心理状态后，眼睛的睫毛如何表达，深度，阴影如何刻画”。而且，在实现工程师具体去设计以后，架构图上的那些线，是要逐步消隐的。
2. 我们做任何一个设计，都必然来自一个约束。“画个人”是我们的约束，这个人坐着还是站在，是我们的“自由”，但我们选择了一个“自由”，我们就增加一个约束了：如果我们决定让这个人坐着，这个人的是手和脚的距离就被约束了。整个“画人”的过程，本质上是不断增加约束的过程，当这个“人”被画好了，所有的约束就变成了“事实”，不可改变了。架构设计，是管理这个约束加入的过程，因为先引入的约束，会控制我们后面引入的约束。

软件的本质是约束。商品的代码不能写在订单域，数据层的方法不能写在业务层。70 年的软件发展，并没有告诉我们应该怎么做，而是教会了我们不该做什么。

道哥：我觉得架构是一个很误导人的概念。我很少提架构，而且我非常谨慎地在提架构。因为现在外面对于架构师的定义是完全不一样的，好像做技术的级别一高就做架构了，有的架构师还不写代码。其实所谓的架构很简单，系统里的结构就是它的架构，架构师的职责就是去把这个系统的结构设计得合理。那么问题就来了，他怎么把这个架构设计得合理？这取决于他的认知水平。他的认知水平取决于什么？为什么中国会有科学院和工程院呢？因为它们还是不一样的，两者的目标不一样。什么是科学，什么是技术呢？很简单，科学是发现这个世界存在的规律，它是发现的过程。技术是发明一个世界上不存在的东西，是个发明的过程。发明和发现的区别，代表了科学和技术的不同。技术里面几个关键的要素，成本、性能、安全。接着谈到什么是系统，系统首先是要做大量的组合，一个系统中间一定有不同的模块。钱学森了不起的地方在于他讲清楚了“对于系统来说，重要的是全局最优，而不是局部最优”。最后，一个好的系统需要通过工程来完成。

我：一个良好的架构，新来一个需求，代码该在哪里加、改是显而易见的，如果不是显而易见的、或者改哪里都可以，那说明原先架构的设计没有体现这个概念，应该动架构。